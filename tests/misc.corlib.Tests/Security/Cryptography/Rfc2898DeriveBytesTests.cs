#region [ license and copyright boilerplate ]
/*
	MiscCorLib.Security.Cryptography
	Rfc2898DeriveBytesTests.cs

	Copyright (c) 2016 Jim Kropa (https://github.com/jimkropa)

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/
#endregion

namespace MiscCorLib.Security.Cryptography
{
	using System;
	using System.IO;
	using System.Linq;
	using System.Security.Cryptography;
	using System.Text;

	using MiscCorLib.Collections.Generic;

	using NUnit.Framework;

	[TestFixture]
	public class Rfc2898DeriveBytesTests
	{
		// Generate a key k1 with password pwd1 and salt salt1.
		// Generate a key k2 with password pwd1 and salt salt1.
		// Encrypt data1 with key k1 using symmetric encryption, creating edata1.
		// Decrypt edata1 with key k2 using symmetric decryption, creating data2.
		// data2 should equal data1.
		[Test]
		public void MsdnExample()
		{
			const string pwd1 = "b@nana!123";
			const int myIterations = 1000;

			// data1 can be a string or contents of a file.
			const string data1 = "Some test data";

			// Create a byte array to hold the random value. 
			byte[] randomSalt = new byte[8];
			using (RNGCryptoServiceProvider rngCsp = new RNGCryptoServiceProvider())
			{
				// Fill the array with a random value.
				rngCsp.GetBytes(randomSalt);
			}

			////	try
			////	{
			// The default iteration count is 1000 so the two methods use the same iteration count.
			Rfc2898DeriveBytes k1 = new Rfc2898DeriveBytes(pwd1, randomSalt, myIterations);
			Rfc2898DeriveBytes k2 = new Rfc2898DeriveBytes(pwd1, randomSalt);

			// Encrypt the data.
			SymmetricAlgorithm encAlg = TripleDES.Create();
			encAlg.Key = k1.GetBytes(16);

			MemoryStream encryptionStream = new MemoryStream();
			CryptoStream encrypt = new CryptoStream(
				encryptionStream, encAlg.CreateEncryptor(), CryptoStreamMode.Write);
			byte[] utfD1 = new UTF8Encoding(false).GetBytes(data1);

			encrypt.Write(utfD1, 0, utfD1.Length);
			encrypt.FlushFinalBlock();
			encrypt.Close();
			byte[] edata1 = encryptionStream.ToArray();

			// Erase memory for optimum secrecy?
			k1.Reset();

			// Try to decrypt, thus showing it can be round-tripped.
			SymmetricAlgorithm decAlg = TripleDES.Create();
			decAlg.Key = k2.GetBytes(16);

			// Relay the one-time INITIALIZATION VECTOR
			// generated by the original encryption.
			// Could this have been initialized via the Rfc k1/k2?
			decAlg.IV = encAlg.IV;

			MemoryStream decryptionStreamBacking = new MemoryStream();
			CryptoStream decrypt = new CryptoStream(
				decryptionStreamBacking, decAlg.CreateDecryptor(), CryptoStreamMode.Write);
			decrypt.Write(edata1, 0, edata1.Length);
			decrypt.Flush();
			decrypt.Close();

			// Erase memory for optimum secrecy?
			k2.Reset();

			string data2 = new UTF8Encoding(false).GetString(decryptionStreamBacking.ToArray());

			if (!data1.Equals(data2))
			{
				Console.WriteLine("Error: The two values are not equal.");
			}
			else
			{
				Console.WriteLine("The two values are equal.");
				Console.WriteLine("k1 iterations: {0}", k1.IterationCount);
				Console.WriteLine("k2 iterations: {0}", k2.IterationCount);
			}
			////	}
			////	catch (Exception e)
			////	{
			////		Console.WriteLine("Error: {0}", e);
			////	}

			Assert.AreEqual(data2, data1);
			Assert.IsTrue(data1.Equals(data2));
		}

		[Test]
		public void SpecifyingSaltSizeGeneratesRandomSalt()
		{
			////	byte[] nullArray = null;
			////	Assert.Throws<ArgumentNullException>(() => nullArray.ToBase64String());

			Console.WriteLine("Empty Byte Array");
			Console.WriteLine((new byte[0]).ToBase64String());
			Console.WriteLine();

			int keySize, blockSize;
			using (SymmetricAlgorithm alg = TripleDES.Create())
			{
				Console.WriteLine("alg.Key");
				Console.WriteLine(alg.Key.ToBase64String(false));
				Console.WriteLine(alg.Key.Length);
				Console.WriteLine(); 

				Console.WriteLine("alg.IV");
				Console.WriteLine(alg.IV.ToBase64String(false));
				Console.WriteLine(alg.IV.Length);
				Console.WriteLine();

				keySize = alg.KeySize;
				blockSize = alg.BlockSize;

				Console.WriteLine("blockSizes = [ {0} ]", alg.LegalBlockSizes.Select(a => a.MaxSize).ToDelimitedString());
				Console.WriteLine();
			}

			Console.WriteLine("keySize = {0}", keySize);
			Console.WriteLine();
			Console.WriteLine("blockSize = {0}", blockSize);
			Console.WriteLine();

			byte[] salt1;
			using (Rfc2898DeriveBytes k1 = new Rfc2898DeriveBytes("whatever", keySize))
			{
				Console.WriteLine("k1.GetBytes(16)");
				Console.WriteLine(k1.GetBytes(16).ToBase64String(false));
				Console.WriteLine();
				Console.WriteLine("k1.GetBytes(16) again");
				Console.WriteLine(k1.GetBytes(16).ToBase64String(false));
				Console.WriteLine();
				Console.WriteLine("k1.Salt");
				Console.WriteLine(k1.Salt.ToBase64String(false));
				Console.WriteLine(k1.Salt.Length);
				Console.WriteLine();

				salt1 = k1.Salt;
			}

			byte[] salt2;
			using (Rfc2898DeriveBytes k2 = new Rfc2898DeriveBytes("whatever", keySize))
			{
				Console.WriteLine("k2.GetBytes(16)");
				Console.WriteLine(k2.GetBytes(16).ToBase64String(false));
				Console.WriteLine();
				Console.WriteLine("k2.GetBytes(16) again");
				Console.WriteLine(k2.GetBytes(16).ToBase64String(false));
				Console.WriteLine();
				Console.WriteLine("k2.Salt");
				Console.WriteLine(k2.Salt.ToBase64String(false));
				Console.WriteLine(k2.Salt.Length);
				Console.WriteLine();

				salt2 = k2.Salt;
			}

			Assert.AreNotEqual(salt1, salt2);

			using (Rfc2898DeriveBytes k3 = new Rfc2898DeriveBytes("whatever", salt2))
			{
				Console.WriteLine("k3.GetBytes(16)");
				Console.WriteLine(k3.GetBytes(16).ToBase64String(false));
				Console.WriteLine();
				Console.WriteLine("k3.GetBytes(16) again");
				Console.WriteLine(k3.GetBytes(16).ToBase64String(false));
				Console.WriteLine();
				Console.WriteLine("k3.Salt");
				Console.WriteLine(k3.Salt.ToBase64String(false));
				Console.WriteLine(k3.Salt.Length);
				Console.WriteLine();

				Assert.AreEqual(salt2, k3.Salt);
			}

			using (SymmetricAlgorithm alg = TripleDES.Create())
			{
				Console.WriteLine("alg.Key");
				Console.WriteLine(alg.Key.ToBase64String(false));
				Console.WriteLine();

				Console.WriteLine("alg.IV");
				Console.WriteLine(alg.IV.ToBase64String(false));
				Console.WriteLine();

				alg.GenerateIV();

				Console.WriteLine("alg.IV again");
				Console.WriteLine(alg.IV.ToBase64String(false));
				Console.WriteLine();
			}
		}
	}
}